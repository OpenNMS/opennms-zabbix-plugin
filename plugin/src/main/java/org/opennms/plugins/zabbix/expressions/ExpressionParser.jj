PARSER_BEGIN(ExpressionParser)

package org.opennms.plugins.zabbix.expressions;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

public class ExpressionParser extends ExpressionParserBase {

    public ExpressionParser() {
        this(new StringReader(""));
    }
}

PARSER_END(ExpressionParser)

// Skip whitespace characters
SKIP : {
  " "
| "\t"
| "\r"
| "\n"
| "\r\n"
}

TOKEN : {
  <LPAREN: "(" >
| <RPAREN: ")" >
| <OPERATOR: (<MINUS>|<MULTIPLICATION>|<DIVISION>|<PLUS>|<AND>|<OR>|<LESS_THAN>|<LESS_THAN_OR_EQUAL>|<MORE_THAN>|<MORE_THAN_OR_EQUAL>|<EQUAL>|<NOT_EQUAL>)>
| <AND: ("AND" | "and" | "&&") >
| <OR: ("OR" | "or" | "||") >
| <MINUS: "-" >
| <NOT: "not" >
| <MULTIPLICATION: "*" >
| <DIVISION: "/" >
| <PLUS: "+" >
| <LESS_THAN: "<" >
| <LESS_THAN_OR_EQUAL: "<=" >
| <MORE_THAN: ">" >
| <MORE_THAN_OR_EQUAL: ">=" >
| <EQUAL: "=" >
| <NOT_EQUAL: "<>" >
| <FUNCTION_CALL: ["a"-"z"](["a"-"z","0"-"9"])+>
| <HOST_AND_KEY: "/" (["a"-"z","A"-"Z","0"-"9"," "])* "/" (["a"-"z","A"-"Z","0"-"9","[","{","#","}","]","."])+ >
| <MACRO: "{" (["a"-"z","A"-"Z",".","0"-"9",",","[","{","#","}","]","\"",":","$"])+ "}"  >
| <NUMBER_WITH_UNIT: <NUMBER>(["a"-"z"])+  >
| <NUMBER: (["0"-"9","."])+  >
}

/** Main production. */
Expression TopLevelExpression() : {
 Expression e;
}
{
  e=CompoundExpression() <EOF>
  { return e; }
}

Term FunctionParameter() : {
   Token body;
   FunctionCall f;
}
{
  f=FunctionCall(){return f;}|body=<HOST_AND_KEY>{return new Constant(body.image);}|body=<NUMBER>{return new Constant(body.image);}|body=<NUMBER_WITH_UNIT>{return new Constant(body.image);}
}

FunctionCall FunctionCall() : {
  List<Term> parameters = new ArrayList<>();
  Term p;
  Token function = null;
}
{
  function=<FUNCTION_CALL>
  <LPAREN>
  p=FunctionParameter(){parameters.add(p);} ("," p=FunctionParameter(){parameters.add(p);})*
  <RPAREN>
  { return new FunctionCall(function.image, parameters); }
}

Constant Constant() : {
  Token c;
}
{
  (c=<NUMBER>|c=<MACRO>)
  { return new Constant(c.image); }
}

Expression Expression() : {
  Term lhs,rhs;
  Token op;
}
{
  (lhs=Constant()|lhs=FunctionCall())
  op=<OPERATOR>
  (rhs=Constant()|rhs=FunctionCall())
  { return new Expression(lhs, op.image, rhs); }
}

Expression CompoundExpression() : {
  Expression lhs,e;
  Token op;
}
{
  lhs=Expression()
  (
    op=<OPERATOR>
    e=Expression()
    {lhs=new Expression(lhs,op.image,e);}
  )*
  { return lhs; }
}
